<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Реестр по сотруднику — авто‑распознавание и печать</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
.sum-print { display: none; }

@media print {
  .no-print, .no-print * { display: none !important; }
  .report-table thead th:first-child,
  .report-table tbody td:first-child { display: none !important; }
#reportWrap { display: block !important; margin: 0 !important; }
  .sum-screen { display: none !important; }
  .sum-print  { display: table-row !important; }
}

  </style>
</head>
<body class="bg-gray-50 text-gray-900">
  <div class="max-w-6xl mx-auto p-4 md:p-8">
    <h1 class="text-2xl md:text-3xl font-bold mb-1 no-print">Форма уведомления об отсутствии на рабочем месте</h1>
    <p class="text-gray-600 mb-6 no-print">Загрузите реестр (XLSX/CSV). Колонки определяются автоматически. Выберите сотрудника и период, затем распечатайте отчёт.</p>

    <!-- Controls -->
    <div id="controls" class="rounded-2xl bg-white shadow p-4 md:p-6 space-y-4 no-print">
      <div class="flex flex-col md:flex-row gap-3 md:items-end">
        <div class="grow">
          <label class="block text-sm font-medium mb-1">Загрузка реестра (XLSX/CSV)</label>
          <input id="fileInput" type="file" accept=".xlsx,.xls,.csv" class="block w-full text-sm file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-gray-100 file:text-gray-700 hover:file:bg-gray-200" />
        </div>
        <div>
          <label class="block text-sm font-medium mb-1">Период: с</label>
          <input id="dateFrom" type="date" class="w-full border rounded-lg px-3 py-2" />
        </div>
        <div>
          <label class="block text-sm font-medium mb-1">по</label>
          <input id="dateTo" type="date" class="w-full border rounded-lg px-3 py-2" />
        </div>
        <div class="grow">
          <label class="block text-sm font-medium mb-1">Сотрудник</label>
          <select id="employeeSelect" class="w-full border rounded-lg px-3 py-2 disabled:bg-gray-100" disabled>
            <option>Загрузите файл…</option>
          </select>
        </div>
        <div class="flex gap-2">
          <button id="btnPrint" class="px-4 py-2 rounded-xl bg-black text-white disabled:opacity-40" disabled>Печать</button>
        </div>
      </div>
      <div id="detectedCols" class="text-xs text-gray-500 no-print"></div>
    </div>

    <!-- Report -->
    <div id="reportWrap" class="mt-6 print-container hidden">
      <div class="bg-white rounded-2xl shadow p-6">
        <div class="flex flex-col md:flex-row md:items-end md:justify-between gap-2 mb-4">
          <div>
            <h2 class="text-xl font-bold">Реестр по сотруднику</h2>
            <div id="repFio" class="text-lg"></div>
          </div>
          <div class="text-sm text-gray-600">
            <div>Период: <span id="repPeriod">—</span></div>
            <div>Сформировано: <span id="repGenerated"></span></div>
          </div>
        </div>
        <div class="text-sm text-gray-600 mb-2 no-print">
  В расчёте ниже «1&nbsp;день» = <b>8 часов</b>.
        </div>
        <div class="overflow-x-auto">
          <table class="w-full border border-gray-200 report-table">
            <thead class="bg-gray-50">
              <tr>
                <th class="border p-2 text-left">#</th>
                <th class="border p-2 text-left">Дата</th>
                <th class="border p-2 text-left">Начало</th>
                <th class="border p-2 text-left">Окончание</th>
                <th class="border p-2 text-left">Событие</th>
                <th class="border p-2 text-right">Часы</th>
              </tr>
            </thead>
            <tbody id="repTbody"></tbody>
<tfoot>
<tr class="sum-screen">
  <td colspan="5" class="border p-2 text-right font-semibold">
    Итого (раб. день = 8 ч):
  </td>
  <td id="repTotalScreen" class="border p-2 text-right font-bold">0</td>
</tr>

<tr class="sum-print">
  <td colspan="4" class="border p-2 text-right font-semibold">
    Итого (раб. день = 8 ч):
  </td>
  <td id="repTotalPrint" class="border p-2 text-right font-bold">0</td>
</tr>

</tfoot>

          </table>
        </div>
      </div>
    </div>

    <div id="toast" class="fixed bottom-4 right-4 hidden"></div>
  </div>

  <script>

function readSmart(ws){
  const rows = XLSX.utils.sheet_to_json(ws,{header:1,defval:'',raw:true});
  if(!rows.length) return {headers:[], data:[]};

  const norm = s => String(s||'').replace(/\n+/g,' ').replace(/[\u00A0]/g,' ').replace(/\s+/g,' ').trim();

  // Оценка «похожести» строки на шапку
  const score = (r)=>{
    const arr=(r||[]).map(norm).filter(Boolean);
    let s=0;
    const rx=[/фио|сотруд|name|employee/i, /дата/i, /событ|причин|event|desc/i];
    rx.forEach(re=>{ if(arr.some(c=>re.test(c))) s++; });
    s -= arr.filter(c=>/^__empty/i.test(c)).length*0.2;
    return s;
  };

  // Находим лучшую строку для заголовков и склеиваем её с предыдущей (на случай многострочности)
  let best=0, bestScore=-1; const maxScan=Math.min(rows.length,40);
  for(let i=0;i<maxScan;i++){ const sc=score(rows[i]); if(sc>bestScore){best=i;bestScore=sc;} }

  const head=rows[best]||[], prev=rows[Math.max(0,best-1)]||[];
  const width=Math.max(head.length,prev.length);
  const headers=[];
  for(let c=0;c<width;c++){
    const a=norm(prev[c]), b=norm(head[c]);
    headers.push((a&&b?`${a} ${b}`:(a||b)) || `Col_${c+1}`);
  }

  const data=[];
  for(let r=best+1;r<rows.length;r++){
    const row=rows[r]; if(!row || row.every(v=>norm(v)==='')) continue;
    const obj={}; headers.forEach((h,i)=> obj[h]=row[i] ?? ''); data.push(obj);
  }
  return {headers, data};
}
    let records = [];
    let rawRows = [];
    let headers = [];
    let cols = {};

    // ===== Утилиты
    function showToast(msg, type = 'ok') {
      const t = document.getElementById('toast');
      t.className = 'fixed bottom-4 right-4 px-4 py-2 rounded-xl shadow text-white ' + (type === 'ok' ? 'bg-emerald-600' : 'bg-rose-600');
      t.textContent = msg;
      t.style.display = 'block';
      setTimeout(() => t.style.display = 'none', 2400);
    }

    function getPickerDateLocal(id) {
  const v = document.getElementById(id)?.value || '';
  if (!v) return null;               // v = 'YYYY-MM-DD'
  const [y, m, d] = v.split('-').map(Number);
  return new Date(y, (m || 1) - 1, d || 1, 0, 0, 0, 0); // ЛОКАЛЬНАЯ полуночь
}


    function resetReport() {
  // данные
  records = [];
  rawRows = [];
  headers = [];
  cols = {};

  // фильтры/селекты
  const sel = document.getElementById('employeeSelect');
  if (sel) {
    sel.innerHTML = '<option value="">— выберите —</option>';
    sel.disabled = true;
  }

  // таблица
  const tbody = document.getElementById('repTbody');
  if (tbody) tbody.innerHTML = '';

  // «Итого»
  const tScreen = document.getElementById('repTotalScreen');
  const tPrint  = document.getElementById('repTotalPrint');
  if (tScreen) { tScreen.textContent = '0'; tScreen.removeAttribute('title'); }
  if (tPrint)  { tPrint.textContent  = '0'; tPrint.removeAttribute('title'); }

  // шапка отчёта
  const repFio = document.getElementById('repFio');
  const repPeriod = document.getElementById('repPeriod');
  const repGenerated = document.getElementById('repGenerated');
  if (repFio) repFio.textContent = '';
  if (repPeriod) repPeriod.textContent = '—';
  if (repGenerated) repGenerated.textContent = '';

  // скрыть блок отчёта и запретить печать
  const wrap = document.getElementById('reportWrap');
  if (wrap) wrap.classList.add('hidden');
  const btnPrint = document.getElementById('btnPrint');
  if (btnPrint) btnPrint.disabled = true;

  // инфо по колонкам
  const det = document.getElementById('detectedCols');
  if (det) det.textContent = '';
}


function formatDurationRu(ms) {
  if (!ms || ms <= 0) return '0 мин';
  const totalSec = Math.round(ms / 1000);
  const days  = Math.floor(totalSec / 86400);
  const hours = Math.floor((totalSec % 86400) / 3600);
  const mins  = Math.floor((totalSec % 3600) / 60);

  const parts = [];
  if (days  > 0) parts.push(`${days}\u00A0дн`);
  if (hours > 0) parts.push(`${hours}\u00A0ч`);
  if (mins  > 0) parts.push(`${mins}\u00A0мин`);

  return parts.join(' ');
}

function formatDurationWorkday(ms, WORKDAY_HOURS = 8) {
  if (!ms || ms <= 0) return '0 мин';
  const totalMinutes = Math.round(ms / 60000);
  const totalHours   = Math.floor(totalMinutes / 60);
  const mins         = totalMinutes % 60;

  const days  = Math.floor(totalHours / WORKDAY_HOURS);  // дни по 8 ч
  const hours = totalHours % WORKDAY_HOURS;

  const parts = [];
  if (days  > 0) parts.push(`${days}\u00A0дн`);
  if (hours > 0) parts.push(`${hours}\u00A0ч`);
  if (mins  > 0) parts.push(`${mins}\u00A0мин`);
  return parts.join(' ') || '0 мин';
}


    function excelDateToJS(v) {
  if (!v) return null;
  if (v instanceof Date) return v;

  // Числовой excel-сериал -> ЛОКАЛЬНАЯ дата/время (без сдвига)
  if (typeof v === 'number') {
    try {
      // Точный разбор через SSF (есть в xlsx.full)
      if (XLSX && XLSX.SSF && XLSX.SSF.parse_date_code) {
        const o = XLSX.SSF.parse_date_code(v);
        if (o) return new Date(o.y, (o.m || 1) - 1, o.d || 1, o.H || 0, o.M || 0, Math.floor(o.S || 0));
      }
    } catch(_) {}
    // Фоллбек: локальная «эпоха» без UTC
    const epochLocal = new Date(1899, 11, 30); // 1899-12-30
    return new Date(epochLocal.getTime() + v * 86400000);
  }

  // Поддержка строк "ДД.ММ.ГГГГ[ ЧЧ:ММ[:СС]]" / "ДД.ММ.ГГ"
  const s = String(v).trim();
  const m = s.match(/^(\d{1,2})\.(\d{1,2})\.(\d{2,4})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
  if (m) {
    let year = parseInt(m[3], 10); if (year < 100) year += 2000;
    return new Date(year, parseInt(m[2],10)-1, parseInt(m[1],10),
                    parseInt(m[4]||'0',10), parseInt(m[5]||'0',10), parseInt(m[6]||'0',10));
  }

  const d = new Date(s);
  return isNaN(d) ? null : d;
}

    function fmtDate(d){ if(!d) return ''; return `${String(d.getDate()).padStart(2,'0')}.${String(d.getMonth()+1).padStart(2,'0')}.${d.getFullYear()}`; }
    function fmtTime(d){ if(!d) return ''; return `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`; }
    function parseTime(val){
      if(!val) return null; if(val instanceof Date) return val;
      if(typeof val==='number'){ const base=new Date(); base.setHours(0,0,0,0); return new Date(base.getTime()+val*86400000); }
      const s=String(val).trim(); const m=s.match(/^(\d{1,2})(?::(\d{2}))?(?::(\d{2}))?$/);
      if(m){ const h=+m[1]||0, mi=+m[2]||0, se=+m[3]||0; const base=new Date(); base.setHours(h,mi,se,0); return base; }
      const d=new Date(s); return isNaN(d)?null:d;
    }
    function diffHours(st,en){ if(!st||!en) return 0; return Math.max(0, Math.round(((en-st)/36e5)*100)/100); }

    // Парсер длительности "0 дней 7 часов 0 минут" (+ HH:MM(:SS), числа/Excel)
    function parseDurationMs(val){
      if(val==null) return 0;
      if(typeof val==='number'){ return val<=1.5 ? Math.round(val*24*3600*1000) : Math.round(val*3600*1000); }
      const s = String(val).toLowerCase().trim();
      const pick = (re)=>{ const m=s.match(re); return m?parseInt(m[1],10)||0:0; };
      const days=pick(/(\d+)\s*(дн(?:ей|я)?|day[s]?)/); const hours=pick(/(\d+)\s*(час(?:ов|а)?|h(?:our)?s?)/); const mins=pick(/(\d+)\s*(минут(?:а|ы)?|мин|m(?:in)?s?)/); const secs=pick(/(\d+)\s*(секунд(?:а|ы)?|сек|s(?:ec)?s?)/);
      let ms = (((days*24+hours)*60+mins)*60+secs)*1000;
      if(ms>0) return ms;
      const hm = s.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
      if(hm){ const h=+hm[1]||0, m=+hm[2]||0, se=+(hm[3]||0); return ((h*60+m)*60+se)*1000; }
      const n = Number(s); if(!isNaN(n)) return Math.round(n*3600*1000);
      return 0;
    }

    // Пересечение двух интервалов времени в миллисекундах
function overlapMs(aStart, aEnd, bStart, bEnd) {
  const s = Math.max(aStart.getTime(), bStart.getTime());
  const e = Math.min(aEnd.getTime(),   bEnd.getTime());
  return Math.max(0, e - s);
}

// Сколько мс из [start, end] попадает в обеденный перерыв(ы)
function lunchOverlapMs(start, end, lunchFrom = "13:00", lunchTo = "14:00") {
  if (!(start instanceof Date) || !(end instanceof Date) || end <= start) return 0;

  // распарсим "HH:MM"
  const [fh, fm] = lunchFrom.split(":").map(n => parseInt(n, 10) || 0);
  const [th, tm] = lunchTo.split(":").map(n => parseInt(n, 10) || 0);

  // Итерация по дням, которые затрагивает интервал [start, end]
  let total = 0;
  // Начинаем с полуночи дня начала
  let dayCursor = new Date(start.getFullYear(), start.getMonth(), start.getDate(), 0, 0, 0, 0);

  // Будем идти по суткам, пока день не превысит конец интервала
  while (dayCursor.getTime() <= end.getTime()) {
    // Окно обеда в рамках текущих суток
    const lunchStart = new Date(dayCursor.getFullYear(), dayCursor.getMonth(), dayCursor.getDate(), fh, fm, 0, 0);
    const lunchEnd   = new Date(dayCursor.getFullYear(), dayCursor.getMonth(), dayCursor.getDate(), th, tm, 0, 0);

    // Пересечение рабочего интервала с обедом за эти сутки
    total += overlapMs(start, end, lunchStart, lunchEnd);

    // следующий день
    dayCursor = new Date(dayCursor.getTime() + 24*3600*1000);
  }
  return total;
}


function normalizeRecord(r, idx) {
  // 1) базовый старт: "Дата и время"
  let start = cols.date ? excelDateToJS(r[cols.date]) : null;

  // 2) если нет – собрать из "Дата начала" + "Время начала"
  if (!start && (cols.startDate || cols.startTime)) {
    const dOnly = cols.startDate ? excelDateToJS(r[cols.startDate]) : null;
    const tOnly = cols.startTime ? parseTime(r[cols.startTime]) : null;
    if (dOnly || tOnly) {
      const d = dOnly
        ? new Date(dOnly.getFullYear(), dOnly.getMonth(), dOnly.getDate(), 0, 0, 0, 0)
        : new Date();
      if (tOnly) d.setHours(tOnly.getHours(), tOnly.getMinutes(), tOnly.getSeconds(), 0);
      start = d;
    }
  }

  // 3) конец по данным
  let end = null;
  if (cols.endTime || cols.endDate) {
    // если есть отдельные поля окончания — соберём
    const tOnly = cols.endTime ? parseTime(r[cols.endTime]) : null;
    const dOnly = cols.endDate ? excelDateToJS(r[cols.endDate]) : (start ? new Date(start) : null);
    if (tOnly || dOnly) {
      const d = dOnly
        ? new Date(dOnly.getFullYear(), dOnly.getMonth(), dOnly.getDate(), 0, 0, 0, 0)
        : new Date();
      if (tOnly) d.setHours(tOnly.getHours(), tOnly.getMinutes(), tOnly.getSeconds(), 0);
      end = d;
    }
  }

  // 4) альтернативный источник — «Итоговое количество времени»
  const rawDur = (cols.hours != null) ? r[cols.hours] : null;

  // 5) финальная длительность
  let durMs = 0;

  if (start && end && end > start) {
    // приоритет: считаем от/до и вычитаем обед(ы)
    const base = end.getTime() - start.getTime();
    const lunch = lunchOverlapMs(start, end, "13:00", "14:00");
    durMs = Math.max(0, base - lunch);
  } else if (rawDur != null && String(rawDur).trim() !== '') {
    // если времени начала/окончания нет — используем «Итоговое кол-во»
    durMs = parseDurationMs(rawDur);
    // НЕТ корректной возможности вычитать обед без start/end, поэтому оставляем как есть
  }

  // 6) итоговые поля
  const fio   = String(r[cols.fio]||'').replace(/\u00A0/g,' ').trim();
  const event = r[cols.event] || '';
  const hoursText = formatDurationRu(durMs); // отображение строкой

  return {
    id: String(idx + 1),
    fio,
    event,
    start: start || null,
    end: end || null,
    durMs: durMs || 0,
    hoursText,
    source: r
  };
}



    function withinPeriod(d) {
  if (!d) return false;

  const f = getPickerDateLocal('dateFrom'); // начало периода (local)
  const t = getPickerDateLocal('dateTo');   // конец периода (local)

  // сравниваем только по дате (локальная полночь)
  const day = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0, 0);

  if (f && day < f) return false;  // ВКЛЮЧИТЕЛЬНО: day === f проходит
  if (t && day > t) return false;  // ВКЛЮЧИТЕЛЬНО: day === t проходит
  return true;
}

    // ===== Поиск колонок по синонимам =====
    function detectColumns(headers){
      const norm = s => String(s||'').toLowerCase().replace(/\u00A0/g,' ').replace(/\s+/g,' ').trim();
      const find = (cands)=>{
        for(const c of cands){ const hit=headers.find(h=>norm(h)===norm(c)); if(hit) return hit; }
        const keys=[...cands].sort((a,b)=>b.length-a.length).map(norm);
        for(const h of headers){ const nh=norm(h); if(keys.some(k=>nh.includes(k))) return h; }
        return null;
      };
      const res = {
        fio:       find(['ФИО','Сотрудник','ФИО сотрудника','Фамилия Имя','Фамилия, имя и отчество','Name','Employee','Full Name']),
        event:     find(['Событие','Причина','Тип события','Описание','Комментарий','Event','Reason','Description']),
        date:      find(['Дата и время','Дата','Дата создания','Date','Created','Creation Date']),
        startDate: find(['Дата начала','Start Date','Начало (дата)']),
        startTime: find(['Время начала','Начало','Start','Start Time']),
        endDate:   find(['Дата завершения','End Date','Окончание (дата)']),
        endTime:   find(['Время завершения','Окончание','End','End Time','Finish']),
        hours:     find(['Итоговое количество времени','Количество времени','Часы','Длительность','Продолжительность','Hours','Duration'])
      };
      res.start = res.startTime; // для совместимости
      res.end   = res.endTime;
      return res;
    }

    // ===== Рендер отчёта =====
function buildReport(fioVal){
  if (!fioVal) return;

  // фильтр по сотруднику и периоду
  let rows = records
    .filter(rec => rec.fio === fioVal)
    .filter(rec => withinPeriod(rec.start || rec.end || null));

  // сортировка по дате
  rows.sort((a,b)=>{
    const ad = (a.start || a.end || 0)?.getTime?.() || 0;
    const bd = (b.start || b.end || 0)?.getTime?.() || 0;
    return ad - bd;
  });

  // рендер строк
  const tbody = document.getElementById('repTbody');
  tbody.innerHTML = '';
  let totalMs = 0;

  rows.forEach((r, i) => {
    totalMs += (r.durMs || 0);
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="border p-2">${i + 1}</td>
      <td class="border p-2">${fmtDate(r.start || r.end)}</td>
      <td class="border p-2">${fmtTime(r.start)}</td>
      <td class="border p-2">${fmtTime(r.end)}</td>
      <td class="border p-2">${r.event}</td>
      <td class="border p-2 text-right" title="${(r.durMs/36e5).toFixed(2)} ч">${r.hoursText}</td>
    `;
    tbody.appendChild(tr);
  });

  // ===== ИТОГО
  const WORKDAY_HOURS = 8;

  // по рабочим дням (8 ч/день)
  const totalTextWork = formatDurationWorkday(totalMs, WORKDAY_HOURS);

  // «сырые» часы и представление по календарю (24 ч/день) — для подсказки
  const totalHoursFloat = totalMs / 36e5;
  const totalText24h    = formatDurationRu(totalMs);
  const tooltip = [
    `${totalHoursFloat.toFixed(2)} ч (сумма)`,
    `${totalText24h} по календарю (24 ч/день)`,
    `${totalTextWork} по рабочим дням (${WORKDAY_HOURS} ч/день)`
  ].join(' · ');

  const cellScreen = document.getElementById('repTotalScreen');
  const cellPrint  = document.getElementById('repTotalPrint');

  if (cellScreen) {
    cellScreen.textContent = `${totalTextWork} (по ${WORKDAY_HOURS} ч/день)`;
    cellScreen.title = tooltip;
  }
  if (cellPrint) {
    cellPrint.textContent  = `${totalTextWork} (по ${WORKDAY_HOURS} ч/день)`;
    cellPrint.title  = tooltip;
  }

  // поддержка альтернативного единственного футера (если есть)
  const repTotal = document.getElementById('repTotal');
  if (repTotal) {
    repTotal.textContent = `${totalTextWork} (по ${WORKDAY_HOURS} ч/день)`;
    repTotal.title = tooltip;
  }

  // заголовки отчёта
  document.getElementById('repFio').textContent = fioVal;
  const df = document.getElementById('dateFrom').value;
  const dt = document.getElementById('dateTo').value;
  document.getElementById('repPeriod').textContent = (df && dt) ? `${df} — ${dt}` : (df || dt || 'все даты');
  document.getElementById('repGenerated').textContent = fmtDate(new Date());
  document.getElementById('reportWrap').classList.remove('hidden');
}



    // ===== Загрузка файла
    document.getElementById('fileInput').addEventListener('change', async (e)=>{
      const file=e.target.files[0]; if(!file) return;
      try{
        resetReport();
        const data=await file.arrayBuffer();
const wb=XLSX.read(data,{type:'array'});
const ws=wb.Sheets[wb.SheetNames[0]];
const smart = readSmart(ws);
rawRows = smart.data;
headers = smart.headers;
if(!rawRows.length) throw new Error('Пустой лист или сложная шапка не распознана.');

        cols = detectColumns(headers);

        // Нормализация всего листа в JSON-модель
records = rawRows.map((r, i) => normalizeRecord(r, i));

// Список сотрудников из records (а не из rawRows)
const uniq = [...new Set(records.map(x => x.fio).filter(Boolean))]
  .sort((a,b)=>a.localeCompare(b,'ru'));
const sel = document.getElementById('employeeSelect');
sel.innerHTML = '<option value="">— выберите —</option>';
uniq.forEach(v => sel.appendChild(new Option(v, v)));
sel.disabled = false;
document.getElementById('btnPrint').disabled = false;

        const det=document.getElementById('detectedCols');
        det.innerHTML = 'Опознаны колонки: ' + [
          `ФИО: <b>${cols.fio||'—'}</b>`,
          `Событие: <b>${cols.event||'—'}</b>`,
          `Дата/время: <b>${cols.date||'—'}</b>`,
          `Старт‑дата: <b>${cols.startDate||'—'}</b>`,
          `Старт‑время: <b>${cols.startTime||'—'}</b>`,
          `Финиш‑дата: <b>${cols.endDate||'—'}</b>`,
          `Финиш‑время: <b>${cols.endTime||'—'}</b>`,
          `Длительность: <b>${cols.hours||'—'}</b>`
        ].join(' · ');

        if(!cols.fio){ showToast('Не нашёл колонку ФИО/Сотрудник — проверьте шапку файла.','err'); return; }
        if(!(cols.date || cols.startDate)){ showToast('Не нашёл «Дата и время» или «Дата начала».','err'); return; }

        showToast('Файл загружен, выберите сотрудника.');
      }catch(err){ console.error(err); showToast('Ошибка: '+err.message,'err'); }
    });

    document.getElementById('employeeSelect').addEventListener('change',e=>buildReport(e.target.value));
    document.getElementById('dateFrom').addEventListener('change',()=>buildReport(document.getElementById('employeeSelect').value));
    document.getElementById('dateTo').addEventListener('change',()=>buildReport(document.getElementById('employeeSelect').value));
    document.getElementById('btnPrint').addEventListener('click',()=>{ if(!document.getElementById('reportWrap').classList.contains('hidden')) window.print(); });
  </script>
</body>
</html>



